#!/usr/bin/env bash
set -e
IFS=$'\n\t'

FFMPEG="/usr/bin/ffmpeg"
ZENITY="/usr/bin/zenity"
NOTIFY="/usr/bin/notify-send"

# Embedded functions to avoid dependency issues
is_valid_file() {
    local input_file="$1"
    local min_size=1024  # 1KB minimum size

    # Check file exists and is readable
    if [[ ! -f "$input_file" || ! -r "$input_file" ]]; then
        return 1
    fi

    # Check file size is reasonable
    local file_size=$(stat -c%s "$input_file" 2>/dev/null || echo 0)
    if [[ $file_size -lt $min_size ]]; then
        return 1
    fi

    # Check if ffprobe can read the file
    if ! ffprobe -v error -show_format "$input_file" >/dev/null 2>&1; then
        return 1
    fi

    return 0
}

detect_video_resolution() {
    local input_file="$1"
    local width height
    width=$(ffprobe -v error -select_streams v:0 -show_entries stream=width -of csv=p=0 "$input_file" 2>/dev/null || echo "0")
    height=$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of csv=p=0 "$input_file" 2>/dev/null || echo "0")
    if [[ "$width" -eq 0 || "$height" -eq 0 ]]; then
        resolution=$($FFMPEG -i "$input_file" 2>&1 | grep -oE "[0-9]{3,5}x[0-9]{3,5}" | head -1)
        if [[ -n "$resolution" ]]; then
            width=$(echo "$resolution" | cut -d"x" -f1)
            height=$(echo "$resolution" | cut -d"x" -f2)
        fi
    fi
    echo "$width,$height"
}

has_video_streams() {
    local input_file="$1"
    local video_streams
    video_streams=$(ffprobe -v error -select_streams v -show_entries stream=codec_type -of csv=p=0 "$input_file" 2>/dev/null)
    if [[ -n "$video_streams" ]]; then
        return 0
    else
        return 1
    fi
}

# Smart conversion to DNxHD/DNxHR intra-frame codecs based on resolution
for INPUT in "$@"; do
  [[ -f "$INPUT" ]] || continue

  DIR="$(dirname "$INPUT")"
  BASENAME="$(basename "$INPUT")"
  EXT="${BASENAME##*.}"
  NAME="${BASENAME%.*}"

  # Check if file is valid and not corrupted
  if ! is_valid_file "$INPUT"; then
    $NOTIFY "Davinci Resolve" "Skipped: $BASENAME (file is corrupted or unreadable)"
    continue
  fi

  # Check if file has video streams
  if ! has_video_streams "$INPUT"; then
    $NOTIFY "Davinci Resolve" "Skipped: $BASENAME (no video streams found)"
    continue
  fi

  # Robust video resolution detection
  resolution=$(detect_video_resolution "$INPUT")
  WIDTH=$(echo "$resolution" | cut -d',' -f1)
  HEIGHT=$(echo "$resolution" | cut -d',' -f2)

  # Calculate total pixels for orientation support
  if [[ "$WIDTH" -gt 0 && "$HEIGHT" -gt 0 ]]; then
    TOTAL_PIXELS=$((WIDTH * HEIGHT))
    THRESHOLD=$((1920 * 1080))  # 1080p threshold = 2,073,600 pixels

    # FFmpeg uses dnxhd encoder for both DNxHD and DNxHR
    # Resolution + profile determines the actual format
    CODEC="dnxhd"
    if [[ $TOTAL_PIXELS -le $THRESHOLD ]]; then
      BITRATE="185M"  # Standard bitrate for 1080p DNxHD
      FRAME_RATE="30"
      CODEC_NAME="DNxHD (1080p)"
    else
      PROFILE="dnxhr_sq"  # DNxHR SQ profile for >1080p resolutions
      FRAME_RATE="30"
      CODEC_NAME="DNxHR SQ (4K+)"
    fi
  else
    $NOTIFY "Davinci Resolve" "Resolution detection failed for $BASENAME (file may be corrupted or unsupported)"
    continue
  fi

  TMP_OUTPUT="$(mktemp --tmpdir="$DIR" ".${NAME}.XXXXXX.mov")"

  # get duration (HH:MM:SS.ms)
  DURATION=$($FFMPEG -i "$INPUT" 2>&1 | grep "Duration" | awk '{print $2}' | tr -d , || echo "00:00:00.00")
  HOURS=${DURATION:0:2}
  MINUTES=${DURATION:3:2}
  SECONDS=${DURATION:6:5}
  TOTAL_SEC=$(echo "$HOURS*3600 + $MINUTES*60 + $SECONDS" | bc)

  # Run FFmpeg with progress tracking
  (
    if [[ $TOTAL_PIXELS -le $THRESHOLD ]]; then
      # DNxHD for ≤1080p with bitrate
      $FFMPEG -y -i "$INPUT" \
        -map 0 \
        -c:v "$CODEC" -b:v "$BITRATE" -r "$FRAME_RATE" -pix_fmt yuv422p \
        -c:a pcm_s24le -ar 48000 \
        -c:s copy \
        -map_metadata 0 \
        "$TMP_OUTPUT" -progress pipe:1 2>/dev/null
    else
      # DNxHR for >1080p with profile
      $FFMPEG -y -i "$INPUT" \
        -map 0 \
        -c:v "$CODEC" -profile:v "$PROFILE" -r "$FRAME_RATE" -pix_fmt yuv422p \
        -c:a pcm_s24le -ar 48000 \
        -c:s copy \
        -map_metadata 0 \
        "$TMP_OUTPUT" -progress pipe:1 2>/dev/null
    fi | \
    while read -r line; do
      if [[ "$line" =~ out_time_ms=([0-9]+) ]]; then
        OUT_MS=${BASH_REMATCH[1]}
        OUT_SEC=$(echo "$OUT_MS / 1000000" | bc)
        # Avoid divide by zero
        if [[ "$TOTAL_SEC" -gt 0 ]]; then
          PCT=$(echo "$OUT_SEC * 100 / $TOTAL_SEC" | bc)
          if [[ "$PCT" -lt 0 ]]; then PCT=0; fi
          if [[ "$PCT" -gt 100 ]]; then PCT=100; fi
        else
          PCT=0
        fi
        echo $PCT
        echo "# Converting $BASENAME to $CODEC_NAME — $(date -u -d @$OUT_SEC +%T) elapsed"
      fi
    done
  ) | $ZENITY --progress --title="$CODEC_NAME conversion" --percentage=0 --auto-close --width=420

  FFmpeg_exit_code=${PIPESTATUS[0]}

  if [[ $FFmpeg_exit_code -ne 0 ]]; then
    $NOTIFY "Davinci Resolve" "Conversion failed: $BASENAME (FFmpeg error $FFmpeg_exit_code)"
    rm -f "$TMP_OUTPUT"
    continue
  fi

  if [[ -f "$TMP_OUTPUT" ]]; then
    # DNxHD/DNxHR requires .mov container, so change extension if needed
    if [[ "$EXT" != "mov" ]]; then
      NEW_BASENAME="${NAME}.mov"
      mv "$INPUT" "${INPUT}.bak"
      mv "$TMP_OUTPUT" "$DIR/$NEW_BASENAME"
      rm -f "${INPUT}.bak"
      $NOTIFY "Davinci Resolve" "Replaced: $BASENAME → $NEW_BASENAME ($CODEC_NAME, ${WIDTH}x${HEIGHT})"
    else
      # Original already has .mov extension, simple replacement
      mv "$INPUT" "${INPUT}.bak"
      mv "$TMP_OUTPUT" "$INPUT"
      rm -f "${INPUT}.bak"
      $NOTIFY "Davinci Resolve" "Replaced: $BASENAME → $CODEC_NAME (${WIDTH}x${HEIGHT})"
    fi
  else
    $NOTIFY "Davinci Resolve" "Conversion failed: $BASENAME"
  fi
done